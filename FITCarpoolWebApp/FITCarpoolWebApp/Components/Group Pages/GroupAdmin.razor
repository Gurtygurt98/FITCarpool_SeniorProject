@page "/GroupAdmin"
@using DataAccessLibrary.Data.Database
@using DataAccessLibrary.Model.Logic_Models
@using MudBlazor
@inject ISchedulesData _dbSchedules
@inject IUsersData _dbUsers

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudSelect Value="selectedYear" Label="Select Year" T="int" ValueChanged="OnYearChanged" Class="mb-4">
        @foreach (var year in years)
        {
            <MudSelectItem Value="year">@year</MudSelectItem>
        }
    </MudSelect>

    <MudSelect Value="selectedWeek" Label="Select Week" T="Week" ValueChanged="OnWeekChanged" Class="mb-4">
        @foreach (var week in weeks)
        {
            <MudSelectItem Value="week">@week.DisplayString</MudSelectItem>
        }
    </MudSelect>
    <MudButton Color="Color.Success" FullWidth="true" OnClick="GenerateGroups">Generate Groups for Selected Week</MudButton>
    <!-- Header that toggles the collapse -->
    <MudPaper Class="pa-2 mb-2" Style="cursor: pointer;" @onclick="ToggleUserList">
        <MudText Typo="Typo.h6" Class="mb-0">User List</MudText>
    </MudPaper>

    <!-- Collapsible content -->
    <MudCollapse Expanded="@isUserListExpanded">
        <MudDataGrid T="UserScheduleEntry" Items="UserList" Bordered="true" Dense="true" ReadOnly="true" Virtualize="true" RowsPerPage="10">
            <Columns>
                <PropertyColumn Property="x => x.UserID" Title="User ID" />
                <PropertyColumn Property="x => x.Start" Title="Start" />
                <PropertyColumn Property="x => x.End" Title="End" />
                <PropertyColumn Property="x => x.Direction" Title="Direction" />
            </Columns>
            <PagerContent>
                <MudDataGridPager T="UserScheduleEntry" />
            </PagerContent>
        </MudDataGrid>
    </MudCollapse>
    <!-- Header that toggles the collapse for Group Data grid -->

    <MudPaper Class="pa-2 mb-2" Style="cursor: pointer;" @onclick="ToggleGroupList">
        <MudText Typo="Typo.h6" Class="mb-0">Group List</MudText>
    </MudPaper>

    <!-- Collapsible content group data grid s-->
    <MudCollapse Expanded="@isGroupListExpanded">
        <MudDataGrid T="DisplayGroupRecModel" Items="displayGroups" Bordered="true" Dense="true" ReadOnly="true" Virtualize="true" RowsPerPage="10">
            <Columns>
                <HierarchyColumn T="DisplayGroupRecModel" />
                <PropertyColumn Property="x => x.window" Title="Arrival/Departure Window"/>
            </Columns>
            <ChildRowContent>
                <MudPaper>
                    @foreach(RecomendedGroup Group in context.Item.groups)
                    {
                        
                    }
                </MudPaper>
            </ChildRowContent>
            <PagerContent>
                <MudDataGridPager T="DisplayGroupRecModel" />
            </PagerContent>
        </MudDataGrid>
    </MudCollapse>
</MudContainer>

@code {
    private List<int> years = new();
    private int selectedYear;
    private List<Week> weeks = new();
    private Week selectedWeek;
    public List<UserScheduleEntry> UserList = new();
    public List<RecomendedGroup> GroupList = new();
    public List<TimeWindow> timeSlots = new();
    public List<DisplayGroupRecModel> displayGroups = new();
    private bool isUserListExpanded = true; // Controls the collapse state
    private bool isGroupListExpanded = true; // Controls the collapse state

    protected override async Task OnInitializedAsync()
    {
        int currentYear = DateTime.Now.Year;
        years = new List<int> { currentYear, currentYear + 1 };
        selectedYear = currentYear;
        GenerateWeeks(selectedYear);
        await OnWeekChanged(weeks.FirstOrDefault(e => e.StartDate.Date == new DateTime(2024, 11, 25)) ?? weeks.First());
    }

    private void OnYearChanged(int newYear)
    {
        selectedYear = newYear;
        GenerateWeeks(selectedYear);
        selectedWeek = null; // Reset selected week
    }

    private async Task OnWeekChanged(Week newWeek)
    {
        selectedWeek = newWeek;
    }

    private void GenerateWeeks(int year)
    {
        weeks.Clear();

        DateTime firstDayOfYear = new DateTime(year, 1, 1);
        DateTime lastDayOfYear = new DateTime(year, 12, 31);

        // Find the Monday of the week that contains January 1st
        int daysSinceMonday = ((int)firstDayOfYear.DayOfWeek - (int)DayOfWeek.Monday + 7) % 7;
        DateTime firstMonday = firstDayOfYear.AddDays(-daysSinceMonday);

        DateTime date = firstMonday;

        // Continue adding weeks while the week overlaps with the selected year
        while (date <= lastDayOfYear.AddDays(6)) // Add 6 to include weeks that end in the next year
        {
            DateTime startDate = date;
            DateTime endDate = date.AddDays(4); // Friday

            // Check if the week overlaps with the selected year
            if (endDate >= firstDayOfYear && startDate <= lastDayOfYear)
            {
                Week week = new()
                    {
                        StartDate = startDate,
                        EndDate = endDate,
                        DisplayString = $"{startDate:MM/dd/yyyy} - {endDate:MM/dd/yyyy}"
                    };

                weeks.Add(week);
            }

            date = date.AddDays(7); // Move to next week
        }
    }

    private void ToggleUserList()
    {
        isUserListExpanded = !isUserListExpanded;
    }
    private void ToggleGroupList()
    {
        isGroupListExpanded = !isGroupListExpanded;
    }
    public class DisplayGroupRecModel
    {
        public List<RecomendedGroup> groups { get; set; }
        public TimeWindow window {get;set;}

    }
    public class Week
    {
        public DateTime StartDate { get; set; } // Monday
        public DateTime EndDate { get; set; }   // Friday
        public string DisplayString { get; set; }
    }
    public class TimeWindow
    {
        public DateTime Start { get; set; }
        public DateTime End { get; set; }  
        public string Direction { get; set; }
        public TimeWindow(DateTime start, DateTime end, string direction)
        {
            Start = start;
            End = end;
            Direction = direction;
        }
    }
    private List<TimeWindow> GenerateTimeSlots(Week week)
    {
        DateTime currentDay = week.StartDate;
        DateTime endTime = week.EndDate.AddDays(1); // Include the last day fully
        List<TimeWindow> timeSlots = new();

        while (currentDay < endTime)
        {
            // Create arrival time slots (7 AM to 12 PM)
            DateTime arrivalStart = currentDay.AddHours(7);
            DateTime arrivalEnd = currentDay.AddHours(12);
            while (arrivalStart < arrivalEnd)
            {
                timeSlots.Add(new TimeWindow(arrivalStart, arrivalStart.AddHours(1), "arrival"));
                arrivalStart = arrivalStart.AddHours(1);
            }

            // Create departure time slots (1 PM to 7 PM)
            DateTime departureStart = currentDay.AddHours(13);
            DateTime departureEnd = currentDay.AddHours(19);
            while (departureStart < departureEnd)
            {
                timeSlots.Add(new TimeWindow(departureStart, departureStart.AddHours(1), "departure"));
                departureStart = departureStart.AddHours(1);
            }

            // Move to the next day
            currentDay = currentDay.AddDays(1);
        }

        return timeSlots;
    }
    public async Task GenerateGroups()
    {
        // Reset group list 
        GroupList = new();
        // Get users from Database that has schedules during the week 
        UserList = await _dbSchedules.GetScheduleEntries(selectedWeek.StartDate, selectedWeek.EndDate);
        // Get list of time slots for that week, run for each
        timeSlots = GenerateTimeSlots(selectedWeek);
        // For each time slot get the users that are in it
        foreach (TimeWindow timeWindow in timeSlots)
        {
            Console.WriteLine("Time Windows " + timeWindow.Start + " " + timeWindow.End);
            // Get the list of user info models
            List<int> UserIds = UserList
                 .Where(e => e.Start >= timeWindow.Start && e.End <= timeWindow.End)
                 .Select(e => e.UserID)
                 .ToList();
            List<UserInfoModel> usersToGroup = await _dbUsers.GetListUserInfoModel(UserIds);
            // Run algo on that list of users to get the best groups, add them to the running list of groups, this will then be displayed in a hierarchical display
            GroupList.AddRange(await HACGrouping(usersToGroup));
            // Groups ordered by their groups  
            displayGroups.Add(new DisplayGroupRecModel());

        }
    }
    public async Task<List<RecomendedGroup>> HACGrouping(List<UserInfoModel> UsersToGroup)
    {
        List<RecomendedGroup> CreatedGroups = new();
        List<List<UserInfoModel>> clusters = UsersToGroup.Select(user => new List<UserInfoModel> { user }).ToList();


        return CreatedGroups;
    }
    
}
